from datetime import datetime, timedelta
from uuid import uuid4


class Flashcard:
    """
    A class to represent a flashcard
    """
    def __init__(self, question, answer, id=str(uuid4()), next_review_date=datetime.now(), repetitions=0,
                 easiness_factor=2.5, interval=0, tags: list[str] = []):
        """
        Constructor for the Flashcard class
        :param question: The question to be answered, will be on the front of the card by default.
        :param answer: The answer to the question, will be on the back of the card by default.
        :param id: The unique identifier for the flashcard, generated by default.
        :param next_review_date: The date the card should be reviewed next, set to the current date by default.
        :param repetitions: The number of times the card has been reviewed, set to 0 by default.
        :param easiness_factor: The easiness factor for the card, set to 2.5 by default, with a minimum of 1.3.
        :param interval: The number of days between reviews, set to 0 by default.
        """
        self.id = id
        self.question = question
        self.answer = answer
        self.next_review_date = datetime.fromisoformat(next_review_date) if \
            (isinstance(next_review_date, str)) else next_review_date
        self.repetitions = repetitions
        self.easiness_factor = easiness_factor
        self.interval = interval
        self.tags = tags

    def review(self, quality: int) -> None:
        """
        Review the flashcard and update the next review date and easiness factor based on the quality/score of the review.
        :param quality: The quality/score of the review, from 0 to 5.
        :return: None
        """
        # Simplified SM-2 Algorithm for spaced repetition
        # In our case, this is if the user clicks "Pass"
        if quality >= 3:
            if self.repetitions == 0:
                self.interval = 1
            elif self.repetitions == 1:
                self.interval = 6
            else:
                self.interval = round(self.repetitions * self.easiness_factor)
            self.repetitions += 1
        else:
            # If the user clicks "Fail", reset the card's repetitions and interval
            self.repetitions = 0
            self.interval = 0  # Slight adjustment to the algorithm to make the user review the card again on the same day

        # Update the easiness factor
        self.easiness_factor = self.easiness_factor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02))
        if self.easiness_factor < 1.3:
            self.easiness_factor = 1.3

        # Update the next review date
        self.next_review_date = datetime.now() + timedelta(days=self.interval)

    def print_stats(self) -> None:
        """
        Print the flashcard's statistics
        :return: None
        """
        print(f"ID: {self.id}")
        print(f"Question: {self.question}")
        print(f"Answer: {self.answer}")
        print(f"Next Review Date: {self.next_review_date}")
        print(f"Repetitions: {self.repetitions}")
        print(f"Easiness Factor: {self.easiness_factor}")
        print(f"Interval: {self.interval}")

    def get_stats(self) -> dict:
        """
        Get the flashcard's statistics
        :return: A dictionary containing the flashcard's statistics
        """
        return {
            "id": self.id,
            "question": self.question,
            "answer": self.answer,
            "next_review_date": self.next_review_date,
            "repetitions": self.repetitions,
            "easiness_factor": self.easiness_factor,
            "interval": self.interval
        }

    def __str__(self):
        return f"Question: {self.question}\nAnswer: {self.answer}\nNext Review Date: {self.next_review_date}"

    def __eq__(self, other):
        return self.question == other.question and self.answer == other.answer

    def __ne__(self, other):
        return not self == other

    def __lt__(self, other):
        return self.next_review_date < other.next_review_date

    def __le__(self, other):
        return self.next_review_date <= other.next_review_date

    def __gt__(self, other):
        return self.next_review_date > other.next_review_date

    def __ge__(self, other):
        return self.next_review_date >= other.next_review_date

    def __repr__(self):
        return f"Flashcard({self.question}, {self.answer}, {self.next_review_date})"
